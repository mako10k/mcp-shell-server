# Confidence と Safety Level に関する仕様検討

## 概要
本ドキュメントでは、`confidence` と `safety_level` の役割、問題点、代替案について議論します。これらのパラメータは現在のコードベースで使用されていますが、ユーザーからその有効性に疑問が呈されており、削除または改善が求められています。

## 現状の仕様

### Confidence
- **役割**: モデルの評価結果に対する信頼度を示す数値。
- **使用箇所**:
  - フォールバックロジックでの条件分岐。
  - LLM の評価結果の一部として出力。
- **問題点**:
  - 値が任意に設定されており、根拠が不明確。
  - 実際のロジックにおいて有意義な判断基準として機能していない。

### Safety Level
- **役割**: 安全性のレベルを示す分類（例: `basic_safe`, `llm_required`）。
- **使用箇所**:
  - 安全性評価の結果を分類するための指標。
  - プロンプト生成やエラーハンドリングに影響。
- **問題点**:
  - 分類基準が曖昧で、実際の安全性を正確に反映していない。
  - 他のロジックと重複している可能性がある。

## フォールバックロジックの詳細

### 現状のフォールバックロジック
- **概要**:
  - LLM の評価が失敗した場合、フォールバックロジックが適用されます。
  - フォールバック時には固定値（例: `confidence: 0.3`）やデフォルトの `safety_level` が設定されます。

- **具体例**:
  1. LLM の応答がタイムアウトした場合、`confidence` に低い値を設定し、エラー処理をスキップ。
  2. 必要なデータが不足している場合でも、`safety_level` を `basic_safe` に設定して処理を継続。

### 問題点
1. **Fail Fast 原則違反**:
   - フォールバックロジックにより、エラーが早期に検出されず、後続の処理で重大な問題を引き起こす可能性があります。
   - 例: 不完全なデータに基づく処理が進行し、誤った結果を生成。

2. **不明確な基準**:
   - フォールバック時の値（例: `confidence: 0.3`）が任意に設定されており、根拠が不明確。
   - フォールバックの適用条件が一貫していない。

### 改善案
1. **Fail Fast 原則の遵守**:
   - エラーが発生した場合は即座に処理を停止し、明確なエラーメッセージを返す。
   - フォールバックを適用する条件を厳格化し、曖昧な値の使用を避ける。

2. **フォールバック条件の明確化**:
   - フォールバックを適用する具体的な条件を定義。
   - 例: 入力データの検証結果や LLM の応答ステータスに基づく条件分岐。

3. **代替案の検討**:
   - フォールバックを完全に廃止し、エラー処理を強化。
   - または、フォールバック時に詳細なログを記録し、後続のデバッグを容易にする。

### LLM の評価に失敗する具体的な事象

LLM の評価が失敗するケースには以下のような事象が含まれます：

1. **タイムアウト**:
   - LLM からの応答が指定された時間内に返されない場合。
   - 例: ネットワーク遅延や LLM サービスの過負荷。

2. **無効な応答**:
   - LLM から返されたデータが期待される形式やスキーマに一致しない場合。
   - 例: 空の応答、JSON パースエラー、不完全なデータ。

3. **エラー応答**:
   - LLM がエラーコードやエラーメッセージを返した場合。
   - 例: "Service Unavailable" や "Invalid Input"。

4. **入力データの不備**:
   - LLM に渡された入力データが不完全または無効である場合。
   - 例: 必須フィールドの欠落、不正なデータ型。

5. **内部エラー**:
   - LLM の内部処理で予期しないエラーが発生した場合。
   - 例: メモリ不足、サーバーのクラッシュ。

これらの失敗事象が発生した場合、現在のロジックではフォールバックが適用されることがありますが、Fail Fast 原則に基づく改善が求められています。

## 検討事項

### Confidence の代替案
1. **削除**:
   - 信頼度を数値で表現する必要がない場合、`confidence` を完全に削除。
   - フォールバックロジックを明確な条件分岐に置き換える。

2. **明確な計算基準の導入**:
   - `confidence` を計算する具体的なアルゴリズムを導入。
   - 例: モデルのスコアや過去の評価結果に基づく動的計算。

### Safety Level の代替案
1. **削除**:
   - 安全性の分類を廃止し、他の指標（例: エラーコードや詳細なログ）で代替。

2. **明確な分類基準の導入**:
   - `safety_level` を決定するための具体的なルールを定義。
   - 例: 入力データの特性やモデルの応答内容に基づく分類。

## 次のステップ
1. **レビュー**:
   - 本ドキュメントの内容をレビューし、`confidence` と `safety_level` の扱いについて決定。

2. **仕様の確定**:
   - 削除または改善の方針を確定。

3. **実装計画**:
   - 確定した仕様に基づき、コードの修正計画を立案。

## 結論
`confidence` と `safety_level` の有効性を再評価し、必要に応じて削除または改善を行うことで、コードの明確性と信頼性を向上させることを目指します。

### セキュリティにおける偽陰性の重要性

セキュリティ関連のロジックにおいて、偽陰性（False Negative）は最も避けるべき事象です。以下にその理由を示します：

1. **偽陰性のリスク**:
   - 偽陰性が発生すると、本来ブロックすべき危険なリクエストやデータが許可されてしまいます。
   - これにより、システムの脆弱性が攻撃者に利用される可能性が高まります。
   - 例: マルウェアの検出に失敗し、システムが侵害される。

2. **Fail Fast 原則の適用**:
   - 偽陰性を防ぐためには、エラーや不確実性が発生した場合に即座に処理を停止し、安全側に倒す（Fail Safe）設計が必要です。
   - フォールバックで曖昧な評価を行うことは、偽陰性を引き起こす可能性があるため避けるべきです。

3. **偽陽性の許容性**:
   - 偽陽性（False Positive）は、無害なリクエストがブロックされることを意味しますが、これはユーザー体験に影響を与えるだけで、セキュリティそのものには直接的な危害を及ぼしません。
   - セキュリティの観点では、偽陽性を許容してでも偽陰性を防ぐべきです。

### 改善案
1. **エラー時の明確な停止**:
   - LLM の評価が失敗した場合は、フォールバックを行わずにエラーを返す。
   - これにより、不確実な状態での処理継続を防ぐ。

2. **安全側への倒し込み**:
   - 不確実な場合は「危険」とみなしてブロックする。
   - 例: LLM の応答が不完全であれば、リクエストを拒否する。

3. **ログとモニタリングの強化**:
   - 偽陽性や偽陰性の発生状況を詳細に記録し、継続的に改善を図る。

これらの原則を設計に組み込むことで、セキュリティの信頼性を向上させることができます。

### 要求仕様に基づく設計方針（修正版）

本システムの設計において、以下の要求仕様を満たすことを最優先とします：

1. **LLMの役割**:
   - LLMは安全性評価の主役（main evaluator）として機能します。
   - 初期フィルタはデフォルトではOFFとなり、すべてのデータがLLMに渡されます。

2. **初期フィルタの役割**:
   - 初期フィルタは、`enhanced-fast` モード時にのみ有効化されます。
   - このモードでは、安全であることが確実なルールに基づき、LLMに渡すデータを最小限に抑えます。
   - 初期フィルタはルールベースで動作し、明確な条件に基づいてデータを分類します。

3. **フォールバックの廃止**:
   - 初期フィルタやLLMの評価が失敗した場合、フォールバックで曖昧な値を設定するのではなく、明確なエラーを返します。
   - これにより、不確実な状態での処理継続を防ぎます。

4. **Fail Fast 原則の適用**:
   - エラーや不確実性が発生した場合には即座に処理を停止し、安全側に倒す設計を採用します。

これらの方針に基づき、システム全体の設計を見直し、要求仕様を確実に満たすようにします。
